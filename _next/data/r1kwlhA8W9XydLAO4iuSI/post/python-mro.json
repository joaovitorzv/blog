{"pageProps":{"post":{"__typename":"Post","title":"Python __mro__","slug":"python-mro","language":"pt-BR","description":"Method Resolution Order ou (MRO) é um que atributo define a ordem em que classes são organizadas, para que os métodos sejam procurados e executados.","date":"2022-01-10","coverImage":{"__typename":"Asset","url":"https://media.graphcms.com/XsA9wtmBTk20bKV6kxQ8","width":5760,"height":3840,"handle":"XsA9wtmBTk20bKV6kxQ8"},"coverImageAlt":"pilha de pedras e um texto escrito MRO","content":{"__typename":"RichText","raw":{"children":[{"type":"paragraph","children":[{"text":"Method Resolution Order ou (MRO) é um que atributo define a ordem em que classes são organizadas, para que os métodos sejam procurados e executados. Em linguagens que não permitem herdar múltiplas classes o MRO não é tão necessário, mas nas que permitem (como Python) ele tem um papel importante."}]},{"type":"paragraph","children":[{"text":"Quando herdamos uma classe a classe herdada pode ser chamada de Parent ou Superclass e a classe que esta herdando Child ou Subclass, o papel do MRO é definir a ordem das Superclasses em que, será procurado por (e caso encontrado, executado) algum método."}]},{"type":"code-block","children":[{"text":"$python$\nclass Grandparent():\n    def method(self):\n        return 'grandparent'\n\nclass Parent(Grandparent):\n    def method(self):\n        return 'parent'\n\nclass Child(Parent):\n    pass\n\nchild = Child()\n\nprint(child.method()) # > 'parent'"}]},{"type":"paragraph","children":[{"text":"um exemplo bem simples (sem fazer o uso de múltiplas heranças) é o código acima, temos 3 classes que possuem o mesmo método, o MRO primeiro procura pelo método na classe instanciada que estamos e caso não seja encontrado procura nas Superclasses, dessa forma: Child -> Parent -> Grandparent."}]},{"type":"paragraph","children":[{"text":"é possível visualizar essa ordem acessando o "},{"code":true,"text":"__mro__"},{"text":" na classe Child"}]},{"type":"code-block","children":[{"text":"$python$\nchild = Child()\n\n# (<class '__main__.Child'>, <class '__main__.Parent'>, <class '__main__.Grandparent'>, <class 'object'>)"}]},{"type":"block-quote","children":[{"type":"heading-three","children":[{"text":"python object class"}]},{"type":"paragraph","children":[{"text":"podemos ver uma classe que não criamos no final "},{"code":true,"text":"<class 'object'>"},{"text":". essa é uma classe built-in do python, ela está presente para ser a Superclass de classes que não tenham explicitamente definido classes para herdar. Por isso a vimos no final do "},{"code":true,"text":"__mro__"},{"text":" pois a classe Grandparent não herda nenhuma outra classe."}]}]},{"type":"paragraph","children":[{"text":"agora utilizando múltiplas heranças vamos ver o MRO cumprindo o seu papel."}]},{"type":"code-block","children":[{"text":"$python$\nclass Grandparent():\n    def method(self):\n        return 'grandparent'\n\nclass Parent(Grandparent):\n    def method(self):\n        return 'parent'\n\nclass Parent2(Grandparent):\n    def method(self):\n        return 'parent2'\n\nclass Child(Parent, Parent2):\n    pass\n\nchild = Child()\n\nprint(child.method()) # > 'parent'\nprint(Child.__mro__)\n# (<class '__main__.Child'>, <class '__main__.Parent'>, <class '__main__.Parent2'>, <class '__main__.Grandparent'>, <class 'object'>)"}]},{"type":"paragraph","children":[{"text":"como você pode na classe child temos o controle da ordem em que as Superclasses serão posicionadas "},{"code":true,"text":"Child(Parent, Parent2)"}]},{"type":"block-quote","children":[{"type":"paragraph","children":[{"text":"essa ordem fica disponível no atributo "},{"code":true,"text":"__bases__"},{"text":" de sua respectiva classe, por exemplo a classe Child acima:"}]},{"type":"code-block","children":[{"text":"$python$\nprint(Child.__bases__)\n# (<class '__main__.Parent'>, <class '__main__.Parent2'>)"}]}]},{"type":"paragraph","children":[{"text":"no exemplo do código acima já começa a ficar interessante, pois o esperado seria que o código tivesse o seguinte MRO"}]},{"type":"paragraph","children":[{"code":true,"text":"Child -> Parent -> Grandparent -> Parent2 -> Grandparent"}]},{"type":"paragraph","children":[{"text":"mas isso não acontece porque como estamos lidando com herança a precedência importa, isso é, a classe "},{"code":true,"text":"Parent2"},{"text":" tem prioridade sobre a "},{"code":true,"text":"Grandparent"},{"text":", então o MRO define a seguinte ordem"}]},{"type":"paragraph","children":[{"code":true,"text":"Child -> Parent -> Parent2 -> GrandParent"}]},{"type":"paragraph","children":[{"text":"então podemos concluir que Subclasses precedem Superclasses (como já dito ali em cima Subclasses, Superclasses = Child, Parent) e o nosso MRO se baseia na ordem do atributo "},{"code":true,"text":"__bases__"}]},{"type":"heading-three","children":[{"text":"Exemplo 2"}]},{"type":"paragraph","children":[{"text":"Se por acaso você tentar criar uma ordem que o MRO não consiga resolver você recebera um TypeError:"}]},{"type":"paragraph","children":[{"text":"\"TypeError: Cannot create a consistent method resolution\norder (MRO) for bases\"","italic":true}]},{"src":"https://media.graphcms.com/j5xTS0cqQIqy2WZzB5X0","type":"image","title":"mro-error.png","width":569,"handle":"j5xTS0cqQIqy2WZzB5X0","height":341,"children":[{"text":""}],"mimeType":"image/png"},{"type":"paragraph","children":[{"text":"no código acima não é possivel criar um Method Resolution Order consistente porque estamos tentando passar uma Superclass na frente de uma Subclass."}]},{"src":"https://media.graphcms.com/BzOYLClTWrI1e5aAUMwH","type":"image","title":"mro-inconsistent.png","width":569,"handle":"BzOYLClTWrI1e5aAUMwH","height":341,"children":[{"text":""}],"mimeType":"image/png"},{"type":"paragraph","children":[{"text":"um workaround para esse erro seria invertendo o "},{"code":true,"text":"__bases__"},{"text":" da classe Child "},{"code":true,"text":"Child(Parent3, Parent)"},{"text":", por mais que funcione existe uma maneira melhor de resolver isso e que vai deixar o seu MRO mais organizado e bem definido e você não terá erros inesperados no futuro.\n"}]},{"type":"code-block","children":[{"text":"$python$\nclass Grandparent():\n    def method(self):\n        return 'grandparent'\n\nclass Parent():\n    def method(self):\n        return 'parent'\n\n    def parent(self):\n        return 'parent hierarquicamente'\n\nclass Parent2(Parent, Grandparent):\n    def method(self):\n        return 'parent2'\n\nclass Parent3(Parent2):\n    pass\n\nclass Child(Parent3):\n    pass\n\nchild = Child()\n\nprint(child.parent()) # parent hierarquicamente"}]},{"type":"paragraph","children":[{"text":"como temos a acesso a todos os métodos e atributos por hierarquia podemos remover a classe "},{"code":true,"text":"Parent"},{"text":" da classe "},{"code":true,"text":"Child"},{"text":"."}]},{"type":"code-block","children":[{"text":"$python$\nprint(Child.__mro__)\n# (<class '__main__.Child'>, <class '__main__.Parent3'>, <class '__main__.Parent2'>, <class '__main__.Parent'>, <class '__main__.Grandparent'>, <class 'object'>)"}]},{"type":"paragraph","children":[{"text":"Acima podemos ver como ficou o MRO, bem definido e não trara problemas no futuro."}]}]}},"tags":["python","poo"]}},"__N_SSG":true}