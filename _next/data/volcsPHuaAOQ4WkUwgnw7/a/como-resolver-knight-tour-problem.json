{"pageProps":{"post":{"__typename":"Post","title":"Como resolver o Knight's Tour Problem","slug":"como-resolver-knight-tour-problem","description":"O Knight's Tour problem é um problema que se baseia em uma sequência de movimentos num tabuleiro de xadrez...","date":"2021-11-16","coverImage":{"__typename":"Asset","url":"https://media.graphcms.com/NKeLOwyDRuicYjlaV6OQ","width":612,"height":408,"handle":"NKeLOwyDRuicYjlaV6OQ"},"coverImageAlt":"chess knight","content":{"__typename":"RichText","raw":{"children":[{"type":"paragraph","children":[{"text":""}]},{"type":"paragraph","children":[{"text":"O "},{"bold":true,"text":"Knight's Tour problem"},{"text":" é um problema que se baseia em uma sequência de movimentos num tabuleiro de xadrez, os movimentos são feitos apenas pelo "},{"text":"Cavalo","italic":true},{"text":" (Knight) e seguindo as regras do xadrez o objetivo é fazer um \"Tour\", ou seja, visitar todas as casas do tabuleiro, porém, só é permitido passar pelas casas apenas uma ÚNICA vez."}]},{"type":"paragraph","children":[{"text":"Existem várias maneiras de resolver esse problema algumas delas são:"}]},{"type":"bulleted-list","children":[{"type":"list-item","children":[{"type":"list-item-child","children":[{"text":"Brute Force"}]}]},{"type":"list-item","children":[{"type":"list-item-child","children":[{"text":"Algoritmos Divide-and-conquer"}]}]},{"type":"list-item","children":[{"type":"list-item-child","children":[{"text":"Rede Neurais"}]}]},{"type":"list-item","children":[{"type":"list-item-child","children":[{"text":"Warnsdorff's Rule (Regra de Warnsdorff's) "}]}]}]},{"type":"paragraph","children":[{"bold":true,"text":"Warnsdorff's Rule"},{"text":" é uma heurística (procedimento que auto-descobre e aplica um método, sem a garantia de ser perfeito ou racional, mas que é suficiente para chegar a um resultado seja ele aproximado ou exato)."}]},{"type":"paragraph","children":[{"text":"Imagine o seguinte cenário: Um tabuleiro padrão 8x8 e a posição inicial do "},{"text":"Cavalo","italic":true},{"text":" atribuída aleatoriamente, uma vez que estamos na posição inicial vamos olhar para todas as casas que o "},{"text":"Cavalo","italic":true},{"text":" pode se mover, partindo dessas casas disponíveis vamos olhar novamente ao redor do "},{"text":"Cavalo","italic":true},{"text":" e contar quantas casas temos disponíveis. A casa que tiver o menor número de futuras casas disponíveis (vamos chama-las de "},{"text":"Neighbors","italic":true},{"text":") é a vencedora e o "},{"text":"Cavalo","italic":true},{"text":" se move até ela, faremos isso até o "},{"text":"Tour","italic":true},{"text":" ser finalizado;"}]},{"src":"https://media.graphcms.com/a9Z1BlNS03Vkui7BdOwM","type":"image","title":"board.png","width":335,"handle":"a9Z1BlNS03Vkui7BdOwM","height":338,"children":[{"text":""}],"mimeType":"image/png"},{"type":"paragraph","children":[{"text":"O nosso tabuleiro será representado por um Array 2D, se quiséssemos posicionar o "},{"text":"Cavalo","italic":true},{"text":" igual na imagem acima (na casa B4) em um Array 2D, seria assim "},{"code":true,"text":"board[4][1]"},{"text":". Como você pode ver temos o Array "},{"code":true,"text":"board"},{"text":" com 8 Arrays representando o eixo X e cada Array com 8 elementos representando o eixo Y."}]},{"type":"code-block","children":[{"text":"$python$\nboard = [[-1 for i in range(n)]for j in range(n)]"}]},{"type":"paragraph","children":[{"text":"Iniciamos todas as casas do tabuleiro com o valor -1 assim fica fácil na hora de saber se o "},{"text":"Cavalo","italic":true},{"text":" ja passou ou por aquela casa."}]},{"type":"paragraph","children":[{"text":"No xadrez o "},{"text":"Cavalo","italic":true},{"text":" faz um movimento em L e para representar isso no nosso código vamos utilizar 2 arrays "},{"code":true,"text":"moves_x = []"},{"text":" e "},{"code":true,"text":"moves_y = []"},{"text":" neles teremos todos os possíveis movimentos que o "},{"text":"Cavalo","italic":true},{"text":" pode fazer"}]},{"type":"code-block","children":[{"text":"$python$\nmoves_x = [-2, -2, -1, -1, 2, 2, 1, 1]\nmoves_y = [-1, 1, -2, 2, -1, 1, -2, 2]"}]},{"type":"paragraph","children":[{"text":"esses números parecem aleatórios e podem soar um pouco confuso, mas calma... tudo fará sentindo."}]},{"src":"https://media.graphcms.com/E5Zf0O49QM6E9BYtqqOc","type":"image","title":"exemplo-moves.png","width":1168,"handle":"E5Zf0O49QM6E9BYtqqOc","height":1166,"children":[{"text":""}],"mimeType":"image/png"},{"type":"paragraph","children":[{"text":"Na ilustração acima fica bem fácil de entender nela temos todos os movimentos em L possíveis, também está destacado em verde o movimento do "},{"text":"Cavalo","italic":true},{"text":" para a casa C7. Todos os movimentos são formados pelo cálculo dos valores "},{"code":true,"text":"moves_x"},{"text":" e "},{"code":true,"text":"moves_y"},{"text":" sobre os valores "},{"bold":true,"text":"X"},{"text":" e "},{"bold":true,"text":"Y"},{"text":" da casa que o "},{"text":"Cavalo","italic":true},{"text":" estiver. Por exemplo para mover da casa D5 ("},{"code":true,"text":"board[3][3]"},{"text":") para a C7 teriamos: X = "},{"code":true,"text":"3 - 2"},{"text":", Y = "},{"code":true,"text":"3 - 1"},{"text":" pronto agora já temos nossa nova posição "},{"code":true,"text":"board[1][2]"}]},{"type":"paragraph","children":[{"text":"Contudo o movimento que fizemos acima só foi válido porquê o cavalo está no centro do tabuleiro, se o "},{"text":"Cavalo","italic":true},{"text":" estiver nas bordas o tabuleiro \"acaba\" ou se já tivesse passado pela casa C7 não poderiamos passar por lá novamente, para verificar isso utilizaremos a seguinte função que recebe "},{"code":true,"text":"next_move"},{"text":" (o resultado do cálculo dos "},{"code":true,"text":"moves"},{"text":" sobre o valor "},{"text":"X","italic":true},{"text":", "},{"text":"Y","italic":true},{"text":" da posição atual), sendo esse um possível movimento valido e também vamos receber o "},{"code":true,"text":"board"}]},{"type":"code-block","children":[{"text":"$python$\ndef validMove(next_move_x, next_move_y, board):\n    if (not next_move_x < 0 and not next_move_y < 0 and next_move_x < n and next_move_y < n and board[next_move_x][next_move_y] == -1):\n        return True\n    return False"}]},{"type":"paragraph","children":[{"text":"Tanto no eixo "},{"bold":true,"text":"X"},{"text":" ou "},{"bold":true,"text":"Y"},{"text":" caso o "},{"text":"Cavalo","italic":true},{"text":" tente fazer um movimento que ultrapasse o limite do tabuleiro o resultado do calculo será negativo e falhara na verificação acima, se esse movimento for feito na borda da direita ou para baixo o resultado será maior que o tamanho do tabueleiro; "},{"code":true,"text":"n"},{"text":" representa o tamanho do tabuleiro (8)"}]},{"type":"paragraph","children":[{"code":true,"text":"solveKnight()"},{"text":" é a nossa função principal"}]},{"type":"code-block","children":[{"text":"$python$\ndef solveKnight():\n    moves_x = [-2, -2, -1, -1, 2, 2, 1, 1]\n    moves_y = [-1, 1, -2, 2, -1, 1, -2, 2]\n\n    board = [[-1 for i in range(n)]for j in range(n)]\n\n    # posição inicial aleatoria\n    starting_pos_x = random.randint(0, 7)\n    starting_pos_y = random.randint(0, 7)\n\n    # começar a contagem de tours \n    # e definir que já passamos por essa posição\n    tour = 1\n    board[starting_pos_x][starting_pos_y] = 1\n\n    # procurar os próximos movimentos\n    findNextMove(moves_x, moves_y, starting_pos_x, starting_pos_y, tour, board, 8)\n    return printBoard(n, board)"}]},{"type":"paragraph","children":[{"text":"aqui chamamos a função "},{"code":true,"text":"findNextMove()"}]},{"type":"code-block","children":[{"text":"$python$\ndef findNextMove(moves_x, moves_y, curr_pos_x, curr_pos_y, tour, board, neighbors_availability):\n    if (tour == 8 ** 2):\n        return True\n\n    next_move_x = None\n    next_move_y = None\n\n    # andar pelo board  \n    for i in range(8):\n        new_move_x = curr_pos_x + moves_x[i]\n        new_move_y = curr_pos_y + moves_y[i]\n\n        if (validMove(new_move_x, new_move_y, board)):\n            # contar quantos neighbors estão disponíveis\n            neighbors_available = countNeighbors(new_move_x, new_move_y, moves_x, moves_y, board)\n            if (neighbors_available < neighbors_availability):\n                neighbors_availability = neighbors_available\n                next_move_x = new_move_x\n                next_move_y = new_move_y\n\n    tour += 1\n    board[next_move_x][next_move_y] = tour\n\n    return findNextMove(moves_x, moves_y, next_move_x, next_move_y, tour, board, 8)"}]},{"type":"paragraph","children":[{"text":"O cavalo já tem sua posição inicial e agora ele precisa começar a andar e para encontrar a próxima casa vamos definir temporariamente um "},{"code":true,"text":"new_move"},{"text":" que será um possível movimento válido, a partir deste "},{"code":true,"text":"new_move"},{"text":" vamos contar quantas outras possíveis casa diponíveis ("},{"code":true,"text":"neighbors"},{"text":") existem, o "},{"code":true,"text":"new_move"},{"text":" que tiver o menor número de "},{"code":true,"text":"neighbors"},{"text":" passa a ser o "},{"code":true,"text":"next_move"}]},{"type":"paragraph","children":[{"text":"Precisamos fazer isso até o "},{"text":"Cavalo","italic":true},{"text":" visitar todas as casas, para isso o retorno desta função será ela mesma, tornando-a recursiva. A cada movimento válido que o "},{"text":"Cavalo","italic":true},{"text":" faz estamos adicionando "},{"code":true,"text":"+1"},{"text":" na variável "},{"code":true,"text":"tour"},{"text":", quando o seu total for igual a "},{"code":true,"text":"8 ** 2"},{"text":" (64) que é o total de casas que existem no nosso tabuleiro saberemos que o Tour foi completo"}]},{"type":"paragraph","children":[{"text":"para contar os neighbors faremos o seguinte"}]},{"type":"code-block","children":[{"text":"$python$\ndef countNeighbors(new_move_x, new_move_y, moves_x, moves_y, board):\n    neighbors = 0\n\n    for i in range(8):\n        neighbor_x = new_move_x + moves_x[i]\n        neighbor_y = new_move_y + moves_y[i]\n\n        if (validMove(neighbor_x, neighbor_y, board)):\n            if (validNeighbor(neighbor_x, neighbor_y, new_move_x, new_move_y)):\n                neighbors += 1\n\n    return neighbors"}]},{"type":"paragraph","children":[{"text":"Iteramos por todos os "},{"code":true,"text":"moves"},{"text":" válidos, como estamos manipulando o "},{"code":true,"text":"new_move"},{"text":" que é uma posição temporária apenas para contar quantos "},{"code":true,"text":"neighbors"},{"text":" disponíveis existem não podemos contar a casa que o cavalo realmente está, e esse é o papel do "},{"code":true,"text":"validNeighbor()"}]},{"type":"code-block","children":[{"text":"$python$\ndef validNeighbor(neighbor_x, neighbor_y, new_move_x, new_move_y):\n    if (neighbor_x != new_move_x and neighbor_y != new_move_y):\n        return True \n    return False"}]},{"type":"paragraph","children":[{"text":"Todos os movimentos que passarem são contados e retornados pela função "},{"code":true,"text":"countNeighbors()"},{"text":"."}]},{"type":"paragraph","children":[{"text":"Agora que o "},{"text":"Cavalo","italic":true},{"text":" já passou por todas as 64 casas precisamos printar na tela todo o caminho feito por ele"}]},{"type":"code-block","children":[{"text":"$python$\ndef printBoard(n, board):\n    for i in range(n):\n        for j in range(n):\n            print(board[i][j], end=' ')\n        print()"}]},{"type":"paragraph","children":[{"text":"Para printar tudo isso iteramos pelo "},{"code":true,"text":"board"},{"text":" e para cada elemento do eixo "},{"bold":true,"text":"X"},{"text":" printamos com o parametro "},{"code":true,"text":"end=' '"},{"text":", porquê o python por padrão cria uma nova linha e o resultado que esperamos é que fiquem um ao lado do outro, assim:"}]},{"type":"code-block","children":[{"text":"$jsx$\n5 20 3 26 7 22 31 36 \n2 27 6 21 30 37 8 23 \n19 4 29 50 25 32 35 38 \n28 1 48 33 56 51 24 9 \n45 18 57 62 49 34 39 52 \n60 63 44 47 42 55 10 13 \n17 46 61 58 15 12 53 40 \n64 59 16 43 54 41 14 11 "}]},{"type":"paragraph","children":[{"text":"esse é o caminho feito pelo "},{"text":"Cavalo","italic":true},{"text":" em um tabuleiro de 8x8."}]},{"type":"paragraph","children":[{"text":"você pode acessar o código completo "},{"href":"https://gist.github.com/joaovitorzv/20898d0e9f781a731a111cf3d9ff3615","type":"link","children":[{"text":"neste gist"}],"openInNewTab":false},{"text":""}]},{"type":"paragraph","children":[{"text":""}]}]}},"tags":["Algoritmos","Python","Knight Tour Problem","Chess"]}},"__N_SSG":true}