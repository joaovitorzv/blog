{"pageProps":{"source":{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    h1: \"h1\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    pre: \"pre\",\n    span: \"span\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Event Propagation\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"When you do a google search various events have been triggered, from you writing what you are looking for\\nto clicking the best result of the search, those interactions can be called events.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"But they not only comes from a user interaction they also can be called programmatically, using the \", _jsx(_components.code, {\n        children: \"dispatchEvent()\"\n      }), \"\\nor calling the method \", _jsx(_components.code, {\n        children: \"click()\"\n      }), \" of an element e.g \", _jsx(_components.code, {\n        children: \"HTMLElement.click()\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"different from the ones triggered by the browser via user interaction, events triggered this way is\\ncalled \\\"synthetic events\\\".\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Event Bubbling and Capturing\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-html\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-tag\",\n          children: [\"<\", _jsx(_components.span, {\n            className: \"hljs-name\",\n            children: \"section\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-attr\",\n            children: \"onClick\"\n          }), \"=\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"console.log('handle section')\\\"\"\n          }), \">\"]\n        }), \"\\n  \", _jsxs(_components.span, {\n          className: \"hljs-tag\",\n          children: [\"<\", _jsx(_components.span, {\n            className: \"hljs-name\",\n            children: \"div\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-attr\",\n            children: \"onClick\"\n          }), \"=\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"console.log('handle div')\\\"\"\n          }), \">\"]\n        }), \"\\n    \", _jsxs(_components.span, {\n          className: \"hljs-tag\",\n          children: [\"<\", _jsx(_components.span, {\n            className: \"hljs-name\",\n            children: \"p\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-attr\",\n            children: \"onClick\"\n          }), \"=\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"console.log('handle p')\\\"\"\n          }), \">\"]\n        }), \"hey i'm a child\", _jsxs(_components.span, {\n          className: \"hljs-tag\",\n          children: [\"</\", _jsx(_components.span, {\n            className: \"hljs-name\",\n            children: \"p\"\n          }), \">\"]\n        }), \"\\n  \", _jsxs(_components.span, {\n          className: \"hljs-tag\",\n          children: [\"</\", _jsx(_components.span, {\n            className: \"hljs-name\",\n            children: \"div\"\n          }), \">\"]\n        }), \"\\n\", _jsxs(_components.span, {\n          className: \"hljs-tag\",\n          children: [\"</\", _jsx(_components.span, {\n            className: \"hljs-name\",\n            children: \"section\"\n          }), \">\"]\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"On the example above we have 3 nested elements, with it's own handlers in this case the \", _jsx(_components.code, {\n        children: \"onClick\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"if I click on the child element \", _jsx(_components.code, {\n        children: \"<p />\"\n      }), \" the event of clicking will trigger its \", _jsx(_components.code, {\n        children: \"onClick\"\n      }), \" handler\\nbut will also bubble up to it's parent elements and trigger their own handlers, that makes sense\\nbecause if we look at the content rendered, when we click on anything inside the \", _jsx(_components.code, {\n        children: \"<section />\"\n      }), \" we\\nare somehow clicking on the \", _jsx(_components.code, {\n        children: \"<section />\"\n      }), \" itself.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now if we go a little back in time, microsoft and netscape came into different conclusions:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"Microsoft said that the innermost element should be triggered first then the outer ones, that's\\ncalled \", _jsx(_components.strong, {\n            children: \"Event Bubbling\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"Netscape said that the outermost element should be triggered first and then the inner ones, that's\\ncalled \", _jsx(_components.strong, {\n            children: \"Event Capturing\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Nowadays all modern browsers support both and the only way to change whether Bubble or Capture is using a\\nlistener\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"⁠myElement.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"addEventListener\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"click\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =>\"\n        }), \" {\\n  ⁠\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"/* block to execute when triggered */\"\n        }), \"\\n⁠}, \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Event Capture\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"⁠myElement.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"addEventListener\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"click\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =>\"\n        }), \" {\\n  ⁠\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"/* block to execute when triggered */\"\n        }), \"\\n⁠}, \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Event Bubble *default*\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"An interesting thing here is that the propagation will always happen, so when working on a very complex DOM\\ntree the bubbling may impact negatively on performance even if there is no other handler found while \\\"bubbling\\\",\\nthus we may end having to disable the propagation using the \", _jsx(_components.code, {\n        children: \"stopPropagation()\"\n      }), \" method\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"⁠myElement.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"addEventListener\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"click\\\"\"\n        }), \", \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"e\"\n          }), \") =>\"]\n        }), \" {\\n⁠  e.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"stopPropagation\"\n        }), \"()\\n⁠})\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Conclusion\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Event propagation order can interfere on which order your handlers is being triggered. By default de event\\nwill bubble up from the innermost to the outermost element, if that's not a desired behavior we can change\\nand use Capture passing \", _jsx(_components.code, {\n        children: \"true\"\n      }), \" as the third parameter of an event listener, also if needed we can disable\\nthe propagation with the \", _jsx(_components.code, {\n        children: \"event.stopPropagation()\"\n      }), \" method.\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"References\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://developer.mozilla.org/en-US/docs/Web/Events\",\n          children: \"MDN Event Reference\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.quirksmode.org/js/events_order.html\",\n          children: \"Quirksmode Events Order\"\n        })\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"meta":{"id":1,"title":"Event Propagation","description":"HTML Event Propagation","date":"03-12-2022","language":"en"}},"__N_SSG":true}