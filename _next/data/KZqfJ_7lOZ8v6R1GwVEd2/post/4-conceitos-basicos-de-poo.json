{"pageProps":{"post":{"__typename":"Post","title":"4 Conceitos básicos de POO","slug":"4-conceitos-basicos-de-poo","language":"pt-BR","description":"Neste post utilizarei os exemplos em python mas os conceitos de POO (Programação Orientada a Objetos) são \"universais\"","date":"2022-01-07","coverImage":{"__typename":"Asset","url":"https://media.graphassets.com/hirPCJTMqT8L2jDyWyg4","width":1600,"height":900,"handle":"hirPCJTMqT8L2jDyWyg4"},"coverImageAlt":"cover with little bears and python logo","content":{"__typename":"RichText","raw":{"children":[{"type":"paragraph","children":[{"text":"Neste post utilizarei os exemplos em python mas os conceitos de POO (Programação Orientada a Objetos) são \"universais\"."}]},{"type":"heading-three","children":[{"text":"1 - Encapsulamento (encapsulation):"}]},{"type":"paragraph","children":[{"text":"O objetivo de \"encapsular\" o código é fazer com que, tudo o que, esteja dentro de determinado bloco de código só possa ser manipulado dentro de si, em python para definir esse bloco de código utilizamos a palavra "},{"code":true,"text":"classe","italic":true},{"text":". para exemplificar melhor vamos criar uma classe pessoa "}]},{"type":"code-block","children":[{"text":"$python$\n⁠class People {\n⁠    ⁠def __init__(self):\n⁠}"}]},{"type":"paragraph","children":[{"text":"todo ser humano é da espécie Homo Sapiens e tem diversos atributos (nome, idade, peso etc)  e provavelmente também realiza ações como andar e falar, essas ações em POO podem ser chamadas de métodos"}]},{"type":"code-block","children":[{"text":"$python$\n⁠class People:\n⁠⁠    species = 'Homo Sapiens' \n⁠\n    def __init__(self, name):\n⁠⁠    ⁠    self.name = name\n⁠\n⁠    def speak(self, msg):\n⁠⁠    ⁠    print(\"{who} disse: {msg}\".format(who=self.name, msg=msg))\n⁠\n    def walk(self):\n⁠⁠    ⁠    print(People.species + \" esta andando...\")"}]},{"type":"paragraph","children":[{"text":"como você pode ver a cima, criamos uma classe "},{"code":true,"text":"People","italic":true},{"text":" com o atributo "},{"code":true,"text":"species"},{"text":" como "},{"text":"'Homo Sapiens'","italic":true},{"text":" , definimos um atributo nome que vai ter seu valor atribuído no momento em que instanciarmos algum objeto "},{"code":true,"text":"People","italic":true},{"text":" e também criamos os métodos "},{"code":true,"text":"speak","italic":true},{"text":" e "},{"code":true,"text":"walk","italic":true},{"text":", aqui já podemos ver o encapsulamento em ação, todos os dados que eu manipular dentro da classe deverão relacionados a uma \"pessoa\""}]},{"type":"code-block","children":[{"text":"$python$\n⁠if __name__ == '__main__':\n⁠⁠    person = People(name='joao')\n⁠⁠    print(person.name) # \"joao\"\n⁠⁠    person.speak('as fumaças falarão por mim') # \"joao disse: as fumaças falarão por mim\"\n⁠⁠    person.walk() # \"Homo Sapiens esta andando...\""}]},{"type":"paragraph","children":[{"text":"note que na instancia person temos acesso aos métodos e também ao atributo "},{"code":true,"text":"name","italic":true},{"text":" da pessoa. Agora imagine que existe um método que possibilita a pessoa de comprar algo, para o bem da simplicidade vamos definir, que, para realizar a compra ela vai precisar passar o número do seu CPF e o nome de algum item"}]},{"type":"code-block","children":[{"text":"$python$\n⁠class People:\n    [...]\n\n    def __init__(self, name, cpf):\n⁠⁠    ⁠    self.name = name\n⁠⁠    ⁠    self.cpf = cpf\n\n    [...]\n\n    def buy(self, item):\n⁠⁠    ⁠    if (self.cpf and item):\n⁠⁠    ⁠        print(\"{who} comprou {item}\".format(who=self.name, item=item))\n⁠\nif __name__ == '__main__':\n⁠⁠    person = People(name='joao', cpf='1234')\n⁠⁠    person.buy('agua') # joao comprou agua\n⁠⁠    print(person.cpf) # 1234"}]},{"type":"paragraph","children":[{"text":"como você pode ver acima, é possível por meio da instância "},{"code":true,"text":"person","italic":true},{"text":" acessar o CPF. Aqui o encapsulamento entra em ação mais uma vez, como o CPF é um dado sigiloso não queremos que ele fique disponível para ser acessado por ai, então vamos fazer com que esse atributo seja privado"}]},{"type":"code-block","children":[{"text":"$python$\n⁠  [...]\n\ndef __init__(self, name, cpf):\n⁠    self.name = name \n⁠    self.__cpf = cpf\n\n  [...]\n\ndef buy(self, item):\n⁠    if (self.__cpf):\n⁠        print(\"{who} comprou {item}\".format(who=self.name, item=item))\n\nif __name__ == '__main__': \n⁠    person = People(name='joao', cpf='1234')\n⁠    person.buy('agua') # joao comprou agua⁠\n⁠⁠    print(person.__cpf) # AttributeError: 'People' object has no attribute '__cpf'\n⁠⁠    print(person.cpf) # AttributeError: 'People' object has no attribute 'cpf'"}]},{"type":"paragraph","children":[{"text":"dessa maneira os dados que fazem sentido serem manipulados apenas dentro da instancia ficam \"blindados\" dentro da classe."}]},{"type":"block-quote","children":[{"text":"Também poderíamos criar métodos privados caso necessário."}]},{"type":"heading-three","children":[{"text":"2 - Abstração "}]},{"type":"paragraph","children":[{"text":"Como o código é encapsulado temos uma melhor abstração da codebase no geral, por exemplo: normalmente quando estamos andando ou falando nosso cérebro não está pensando quantos centímetros vamos abrir a perna ou a velocidade que falamos, apenas executamos essa ação de uma forma \"automática\", aqui algo parecido acontece, quando chamamos o método "},{"code":true,"text":"person.speak('blah blah blah')"},{"text":" da instancia "},{"code":true,"text":"person","italic":true},{"text":" toda ação simplesmente é executada"}]},{"type":"heading-three","children":[{"text":"3 - Herança (Inheritance)"}]},{"type":"paragraph","children":[{"text":"Esse conceito nos permite com que o código possa ser reutilizado de uma forma inteligente dentro da nossa codebase"}]},{"type":"code-block","children":[{"text":"$python$\n⁠# em outro arquivo importamos \n⁠# a classe que desejamos herdar\n⁠from people import People\n⁠\n⁠class Superhero(People):\n⁠    species = 'superhero'\n⁠\n    def __init__(self, name):\n⁠        self.name = name\n⁠\n    def invisibility(self):\n⁠        print('estou invisível')\n⁠\nif __name__ == '__main__':\n    ⁠hero = Superhero('ben 10')\n⁠    print(hero.species) # superhero\n⁠    hero.speak('estou falando') # ben 10 disse: estou falando\n⁠    hero.invisibility() # estou invisível"}]},{"type":"paragraph","children":[{"text":"acima criamos uma nova classe Superhero e herdamos a classe People, dessa forma é possivel reutilizar o método "},{"code":true,"text":"speak","italic":true},{"text":" criado na classe "},{"text":"pai","italic":true},{"text":" ("},{"code":true,"text":"People","italic":true},{"text":")"}]},{"type":"heading-three","children":[{"text":"4 - Polimorfismo (Polymorphism)"}]},{"type":"paragraph","children":[{"text":"um exemplo bem pratico de polimorfismo é o operador '+',  é possivel utiliza-lo para realizar operações \"distintas\""}]},{"type":"code-block","children":[{"text":"$python$\nx = 1\ny = 2\n\nsum = x + y # 3\n# ou\nstr = x + ' ' + y # \"1 3\"\n"}]},{"type":"paragraph","children":[{"text":"mas como estamos falando de POO, vamos utilizar polimorfismo em nossas classes"}]},{"type":"code-block","children":[{"text":"$python$\nclass Superhero():\n    species = 'superhero'\n    def __init__(self, name):\n        self.name = name\n\n    def invisibility(self):\n        print('estou invisivel')\n\n    def dna(self):\n        return 'super-dna'\n\nclass Robot():\n    species = 'iron'\n\n    def __init__(self, name):\n        self.name = name\n\n    def dna(self):\n        return \"01101011\"\n\nif __name__ == '__main__':\n    hero = Superhero('ben 10')\n    robot = Robot('bot')\n\n    for i in (hero, robot):\n        print(i.dna()) # super-dna, 01101011"}]},{"type":"paragraph","children":[{"text":"criei a classe robot para deixar o exemplo mais dinâmico, como você pode ver as classes não são conectadas de nenhuma forma e nem herdam uma classe em comum, porem, elas compartilham de um método com o mesmo nome "},{"code":true,"text":"dna","italic":true},{"text":", dessa forma (sabendo que eles existem) podemos realizar a operação acima, sem se preocupar. Isso só é possivel por causa do polimorfismo."}]},{"type":"paragraph","children":[{"text":"em alguns casos quando herdando algum método que não resolve completamente o seu problema é necessário re-implementar o método herdado, isso é chamado de "},{"bold":true,"text":"method overriding","italic":true}]},{"type":"code-block","children":[{"text":"$python$\nclass Robot(People):\n    species = 'iron'\n\n    def __init__(self, name):\n        self.name = name\n\n    def dna(self):\n        return \"010101010101\"\n\n    def speak(self):\n        print(\"não quero conversar.\")\n\n\nif __name__ == '__main__':\n    robot = Robot('bot')\n\n    robot.speak() # \"não quero conversar.\""}]},{"type":"paragraph","children":[{"text":"no exemplo acima a classe "},{"code":true,"text":"Robot","italic":true},{"text":" herda a classe "},{"code":true,"text":"People","italic":true},{"text":" mas como o robot não está muito amigável o método speak foi re-implementado e se comporta de uma forma distinta da sua classe "},{"text":"pai","italic":true},{"text":"."}]}]}},"tags":["POO"," pogramação orientada a objetos","python"]}},"__N_SSG":true}