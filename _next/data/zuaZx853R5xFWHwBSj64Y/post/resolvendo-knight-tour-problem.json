{"pageProps":{"post":{"__typename":"Post","title":"Knight's Tour Problem","date":"2021-11-16","coverImage":{"__typename":"Asset","url":"https://media.graphcms.com/NKeLOwyDRuicYjlaV6OQ","width":612,"height":408},"content":{"__typename":"RichText","markdown":"O **Knight's Tour problem** é um problema que se baseia em uma sequência de movimentos num tabuleiro de xadrez, os movimentos são feitos apenas pelo **Cavalo** (Knight) e seguindo as regras do xadrez o objetivo é fazer um \"Tour\", ou seja, visitar todas as casas do tabuleiro, porém, só é permitido passar pelas casas apenas uma ÚNICA vez.\n\nExistem várias maneiras de resolver esse problema algumas delas são:\n\n-   Brute Force\n-   Divide-and-conquer Algorithms\n-   Neural Network\n-   Warnsdorff's Rule\n\n**Warnsdorff's Rule** é uma heurística (procedimento que auto-descobre e aplica um método, sem a garantia de ser perfeito ou racional, mas que é suficiente para chegar a um resultado seja ele aproximado ou imediato).\n\nImagine o seguinte cenário: Um tabuleiro padrão 8x8 e a posição inicial do **Cavalo** atribuída randomicamente, uma vez posição inicial vamos olhar para todas as casas que o **Cavalo** pode se mover, partindo dessas casas disponíveis vamos olhar novamente ao redor do cavalo e contar quantas casas temos disponíveis. A casa que tiver o menor numero de futuras casas disponíveis (vamos chama-las de**Neighbors**) é a vencedora e o **Cavalo** se move até ela, faremos isso até o **Tour** ser finalizado;\n\n![board.png](https://media.graphcms.com/a9Z1BlNS03Vkui7BdOwM \"board.png\")\n\nO nosso tabuleiro será representado por um Array 2D, se quiséssemos posicionar o**Cavalo** igual na imagem acima (na casa B4) em um Array 2D, seria assim \\`board\\[4]\\[1]\\`. Você pode ver que temos um Array \\`board\\` com 8 Arrays representando o eixo X e cada Array com 8 elementos representando o eixo Y.\n\n\\`\\`\\`python\n\nboard = \\[\\[-1 for i in range(n)]for j in range(n)]\n\n\\`\\`\\`\n\nIniciamos todas as casas do tabuleiro com o valor -1 assim fica fácil na hora de saber se o **Cavalo** já passou ou por aquela casa.\n\nNo xadrez o **Cavalo** faz um movimento em L, para representar isso no nosso código vamos utilizar 2 arrays \\`moves_x = \\[]\\` e \\`moves_y = \\[]\\` neles teremos todos os possiveis movimentos que o **Cavalo**pode fazer\n\n\\`\\`\\`python\n\nmoves_x = \\[-2, -2, -1, -1, 2, 2, 1, 1]\n\nmoves_y = \\[-1, 1, -2, 2, -1, 1, -2, 2]\n\n\\`\\`\\`\n\nesses números parecem aleatórios e podem soar um pouco confuso, mas calma... tudo fará sentindo.\n\n\n\n![exemplo-moves.png](https://media.graphcms.com/resize=,width:1168,height:1166/yb8mz9STQ6gjUT5wBntW \"exemplo-moves.png\")\n\nna ilustração acima fica bem fácil de entender nela temos todos os movimentos em L possiveis, também está destacado em verde o movimento do **Cavalo** para a casa C7. Todos os movimentos são formados pelo calculo dos valores \\`moves_x\\` e \\`moves_y\\` sobre o os valores **X** e **Y** da casa que o **Cavalo** estiver. Por exemplo para mover da casa D5 (\\`board\\[3]\\[3]\\`) para a C7 teriamos: X = \\`3 - 2\\`, Y = \\`3 - 1\\` pronto agora já temos nossa nova posição \\`board\\[1]\\[2]\\`.\n\nO movimento que fizemos acima só foi válido porquê o cavalo está no centro do tabuleiro, se o **Cavalo** estiver nas bordas o tabuleiro \"acaba\" ou se já tivesse passado pela casa C7 não poderiamos passar por lá novamente, para verificar isso utilizaremos a seguinte função que recebe o tabuleiro \\`board\\` e o \\`next_move\\` com o resultado do cálculo dos \\`moves\\` sobre o valor **X**, **Y** da posição atual, sendo esse um possivel movimento valido\n\n\\`\\`\\`python\n\ndef validMove(next_move_x, next_move_y, board):\n\nif (not next_move_x &lt; 0 and not next_move_y &lt; 0 and next_move_x &lt; n and next_move_y &lt; n and board\\[next_move_x]\\[next_move_y] == -1):\n\nreturn True\n\nreturn False\n\n\\`\\`\\`\n\nTanto no eixo **X** ou **Y** caso o **Cavalo** tente fazer um movimento que ultrapasse o limite do tabuleiro o resultado do calculo será negativo e falhará na verificação acima e se esse movimento for feito na borda da direita ou para baixo o resultado será maior que o tamanho do tabueleiro; \\`n\\` representa o tamanho do tabuleiro (8)\n\n\\`solveKnight()\\` é a nossa função principal\n\n\\`\\`\\`python\n\ndef solveKnight():\n\nmoves_x = \\[-2, -2, -1, -1, 2, 2, 1, 1]\n\nmoves_y = \\[-1, 1, -2, 2, -1, 1, -2, 2]\n\n\n\nboard = \\[\\[-1 for i in range(n)]for j in range(n)]\n\n\n\n\\# posição inicial aleatoria\n\nstarting_pos_x = random.randint(0, 7)\n\nstarting_pos_y = random.randint(0, 7)\n\n\n\n\\# começar a contagem de tours\n\n\\# e definir que já passamos por essa posição\n\ntour = 1\n\nboard\\[starting_pos_x]\\[starting_pos_y] = 1\n\n\n\n\\# procurar os proximos movimentos\n\nfindNextMove(moves_x, moves_y, starting_pos_x, starting_pos_y, tour, board, 8)\n\nreturn printBoard(n, board)\n\n\\`\\`\\`\n\naqui chamamos a função \\`findNextMove()\\`\n\n\\`\\`\\`python\n\ndef findNextMove(moves_x, moves_y, curr_pos_x, curr_pos_y, tour, board, neighbors_availability):\n\nif (tour == 8 \\*\\* 2):\n\nreturn True\n\n\n\nnext_move_x = None\n\nnext_move_y = None\n\n\n\n\\# walk through board\n\nfor i in range(8):\n\nnew_move_x = curr_pos_x + moves_x\\[i]\n\nnew_move_y = curr_pos_y + moves_y\\[i]\n\n\n\nif (validMove(new_move_x, new_move_y, board)):\n\n\\# look for available move with less possible future moves\n\nneighbors_available = countNeighbors(new_move_x, new_move_y, moves_x, moves_y, board)\n\nif (neighbors_available &lt; neighbors_availability):\n\nneighbors_availability = neighbors_available\n\nnext_move_x = new_move_x\n\nnext_move_y = new_move_y\n\n\n\ntour += 1\n\nboard\\[next_move_x]\\[next_move_y] = tour\n\n\n\nreturn findNextMove(moves_x, moves_y, next_move_x, next_move_y, tour, board, 8)\n\n\\`\\`\\`\n\nPara encontrar a próxima casa vamos definir temporariamente um \\`new_move\\` que será um possivel movimento válido, a partir deste \\`new_move\\` vamos contar quantas outras possiveis casa diponíveis (\\`neighbors\\`) existem, o \\`new_move\\` que tiver o menor numero de \\`neighbors\\` passa a ser o \\`next_move\\`\n\n\n\nPrecisamos fazer isso até o**Cavalo** visitar todas as casas, para isso o retorno da nossa função será ela mesma, tornando-a recursiva. A cada movimento válido que o **Cavalo** faz estamos adicionando \\`+1\\` na variável \\`tour\\`, quando o seu total for igual a \\`8 \\*\\* 2\\` (64) que é o total de casas que existem no nosso tabuleiro saberemos que o Tour foi completo\n\n\n\npara contar os neighbors faremos o seguinte\n\n\\`\\`\\`python\n\ndef countNeighbors(new_move_x, new_move_y, moves_x, moves_y, board):\n\nneighbors = 0\n\n\n\nfor i in range(8):\n\nneighbor_x = new_move_x + moves_x\\[i]\n\nneighbor_y = new_move_y + moves_y\\[i]\n\n\n\nif (validMove(neighbor_x, neighbor_y, board)):\n\nif (validNeighbor(neighbor_x, neighbor_y, new_move_x, new_move_y)):\n\nneighbors += 1\n\n\n\nreturn neighbors\n\n\\`\\`\\`\n\n\n\nIteramos por todos os \\`moves\\` válidos, como estamos manipulando o \\`new_move\\` que é uma posição temporaria apenas para contar quantas casas disponíveis existem não podemos contar a casa que o cavalo realmente está, e esse é o papel do \\`validNeighbor()\\`\n\n\n\n\\`\\`\\`python\n\ndef validNeighbor(neighbor_x, neighbor_y, new_move_x, new_move_y):\n\nif (neighbor_x != new_move_x and neighbor_y != new_move_y):\n\nreturn True\n\nreturn False\n\n\\`\\`\\`\n\n\n\nE todos os movimentos que passarem são contados e retornados pela função \\`countNeighbors()\\`.\n\n\n\nAgora que o**Cavalo** já passou por todas as 64 casas precisamos printar na tela todo o caminho feito por ele\n\n\\`\\`\\`python\n\ndef printBoard(n, board):\n\nfor i in range(n):\n\nfor j in range(n):\n\nprint(board\\[i]\\[j], end=' ')\n\nprint()\n\n\\`\\`\\`\n\nPara printar tudo isso iteremos pelo \\`board\\` e para cada elemento do eixo **X** printamos com o parametro \\`end=' '\\`, porquê o python por padrão cria uma nova linha e o resultado que esperamos é que fiquem um ao lado do outro, assim:\n\n~~~python\n\n5 20 3 26 7 22 31 36\n\n2 27 6 21 30 37 8 23\n\n19 4 29 50 25 32 35 38\n\n28 1 48 33 56 51 24 9\n\n45 18 57 62 49 34 39 52\n\n60 63 44 47 42 55 10 13\n\n17 46 61 58 15 12 53 40\n\n64 59 16 43 54 41 14 11\n\n~~~\n\nEsse é o caminho feito pelo **Cavalo** em um tabuleiro de 8x8.\n\nvocê pode acessar o código completo [neste gist](https://gist.github.com/joaovitorzv/20898d0e9f781a731a111cf3d9ff3615 \"https://gist.github.com/joaovitorzv/20898d0e9f781a731a111cf3d9ff3615\")\n"}}},"__N_SSG":true}